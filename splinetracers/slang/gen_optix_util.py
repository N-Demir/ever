# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

util = """
// Generated by gen_optix_util.py

uint optixGetHitKind() {
  __intrinsic_asm "optixGetHitKind()";
}

"""
for n in range(32):
    util += f"""

void set_payload{n}(uint v) {{
  __intrinsic_asm "optixSetPayload_{n}($0)";
}}

uint get_payload{n}() {{
  __intrinsic_asm "optixGetPayload_{n}()";
}}

    """

for n in range(8):
    hit_args = ', '.join([f"${i+2}" for i in range(n+1)])
    fn_args = ", ".join([f"in uint p{i}" for i in range(n+1)])
    util += f"""
uint optixGetAttribute_{n}() {{
  __intrinsic_asm \"optixGetAttribute_{n}()\";
}}
    """

for n in range(8):
    hit_args = ', '.join([f"${i+2}" for i in range(n+1)])
    fn_args = ", ".join([f"in uint p{i}" for i in range(n+1)])
    util += f"""
bool optixReportHit(float t, uint hitKind, {fn_args}) {{
  __intrinsic_asm \"optixReportIntersection($0, $1, {hit_args})\";
}}
    """

# better set payload

util += """
[ForceInline]
void set_payload(uint i, uint val) {
    switch (i) {
"""

for n in range(32):
    util += f"""
    case {n}:
        return set_payload{n}(val);
    """
util += """
    }
}
"""

# better get payload

util += """
[ForceInline]
uint get_payload(uint i) {
    switch (i) {
"""

for n in range(32):
    util += f"""
    case {n}:
        return get_payload{n}();
    """
util += """
    }
}
"""

for n in range(33):
    trace_args = ', '.join([f"${i+5}" for i in range(n)])
    fn_args = "\n".join([f"      in uint p{i}, // ${i+5}" for i in range(n)])
    arg_list = ", ".join([f"p{i}" for i in range(n)])
    init_list = "\n".join([f"    p{i} = (*$5)[{i}];" for i in range(n)])
    finish_list = "\n".join([f"    (*$5)[{i}] = p{i};" for i in range(n)])
    util += f"""

void optixTraceP{n}(
      in RaytracingAccelerationStructure handle, //$0
      in float3 ray_origin, //$1
      in float3 ray_direction, //$2
      in float tmin, //$3
      in float tmax, //$4
      inout uint[{n}] payload,
)
{{
  __intrinsic_asm R"(
  uint {arg_list};
  {init_list}
    optixTrace(
            $0,
            $1,
            $2,
            $3,
            $4,
            0.0f,                // rayTime
            OptixVisibilityMask( 255 ),
            OPTIX_RAY_FLAG_NONE,
            0,                   // SBT offset
            0,                   // SBT stride
            0,                   // missSBTIndex
            {arg_list}); // payload
  {finish_list}
  )";
}}
"""

for n in range(32):
    trace_args = ', '.join([f"${i+5}" for i in range(n)])
    fn_args = "\n".join([f"      in uint p{i}, // ${i+5}" for i in range(n)])
    util += f"""

void optixTrace{n}(
      in RaytracingAccelerationStructure handle, //$0
      in float3 ray_origin, //$1
      in float3 ray_direction, //$2
      in float tmin, //$3
      in float tmax, //$4
{fn_args}
)
{{
  __intrinsic_asm R"(
    optixTrace(
            $0,
            $1,
            $2,
            $3,
            $4,
            0.0f,                // rayTime
            OptixVisibilityMask( 255 ),
            OPTIX_RAY_FLAG_NONE,
            0,                   // SBT offset
            0,                   // SBT stride
            0,                   // missSBTIndex
            {trace_args}); // payload
  )";
}}
"""

with open("optix-intrinsics.slang", "w") as f:
    f.write(util)
